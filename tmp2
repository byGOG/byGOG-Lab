    document.execCommand('copy');
    document.body.removeChild(temp);
  }
}

function setupCopyDelegation() {
  const container = document.getElementById('links-container');
  if (!container || container.dataset.copyDelegation === 'on') return;
  container.dataset.copyDelegation = 'on';
  container.addEventListener('click', async ev => {
    const target = ev.target;
    if (!target || !target.closest) return;
    const btn = target.closest('button.copy-button');
    if (!btn || !container.contains(btn)) return;
    ev.preventDefault();
    ev.stopPropagation();
    if (btn.disabled) return;

    const defaultLabel = btn.dataset.labelDefault || 'Kopyala';
    const successLabel = btn.dataset.labelSuccess || 'Kopyalandı';
    const errorLabel = btn.dataset.labelError || 'Kopyalanamadı';
    const loadingLabel = btn.dataset.labelLoading || 'Kopyalanıyor';
    const baseAriaLabel = btn.dataset.ariaBase || defaultLabel;
    const sr = btn.querySelector('.sr-only');

    const resetState = (label, className, iconName, ariaLabel) => {
      btn.classList.remove('copy-error', 'copied', 'copy-loading');
      if (className) btn.classList.add(className);
      if (sr) sr.textContent = label;
      btn.setAttribute('aria-label', ariaLabel || label);
      setCopyIconOnButton(btn, iconName || 'copy');
      btn.disabled = false;
    };

    btn.disabled = true;
    btn.classList.remove('copy-error', 'copied');
    btn.classList.add('copy-loading');
    setCopyIconOnButton(btn, 'loading');
    if (sr) sr.textContent = loadingLabel;
    btn.setAttribute('aria-label', loadingLabel);

    try {
      await copyToClipboard(btn.dataset.copy || '');
      resetState(successLabel, 'copied', 'success');
    } catch {
      resetState(errorLabel, 'copy-error', 'error');
    }

    if (btn._resetTimer) clearTimeout(btn._resetTimer);
    btn._resetTimer = setTimeout(() => {
      resetState(defaultLabel, null, 'copy', baseAriaLabel);
    }, 2000);
  });
}

const SEARCH_LOCALE = "tr";
const DIACRITIC_PATTERN = /[\u0300-\u036f]/g;

function normalizeForSearch(value) {
  return String(value || "").toLocaleLowerCase(SEARCH_LOCALE);
}

function foldForSearch(value) {
  // Turkish-friendly folding: remove diacritics and unify dotless i -> i
  return normalizeForSearch(value)
    .normalize("NFD")
    .replace(DIACRITIC_PATTERN, "")
    .replace(/ı/g, "i");
}

function tokenizeFoldedQuery(value) {
  return foldForSearch(value).split(/\s+/).filter(Boolean);
}

function escapeRegExp(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\$&");
}

function buildHighlightRegex(value) {
  const tokens = normalizeForSearch(value).trim().split(/\s+/).filter(Boolean);
  if (!tokens.length) return null;
  return new RegExp(`(${tokens.map(escapeRegExp).join("|")})`, "gi");
}

function createHighlightMeta(value) {
  const hasQuery = value.trim().length > 0;
  return {
    raw: value,
    hasQuery,
    regex: hasQuery ? buildHighlightRegex(value) : null
  };
}

function applyHighlight(node, _regex) {
  const label = node.querySelector(".link-text");
  if (label) {
    const original = node.dataset.nameOriginal || label.textContent || "";
    label.textContent = original;
  }
  const tip = node.querySelector(".custom-tooltip");
  if (tip) {
    const descOriginal = node.dataset.descOriginal || "";
    if (descOriginal) {
      const img = tip.querySelector("img");
      // Rebuild tooltip content without any highlighting
      try {
        tip.innerHTML = "";
        if (img) {
          tip.appendChild(img);
          tip.appendChild(document.createTextNode(" "));
        }
        tip.appendChild(document.createTextNode(descOriginal));
      } catch {
        // Fallback: set plain text
        tip.textContent = descOriginal;
      }
    }
  }
}

// Category visibility is managed via counters for performance
// Toggling happens in createMatchApplier using 'is-hidden' class
function updateCategoryVisibility() {}

function createMatchApplier(nodes, dataset, status) {
  const visible = new Set(dataset.map(entry => entry.index));
  const catCounts = new Map();
  const subCounts = new Map();
  dataset.forEach(entry => {
    if (!entry.isLink) return;
    const cat = entry.catEl;
    const sub = entry.subEl;
    catCounts.set(cat, (catCounts.get(cat) || 0) + 1);
    if (sub) subCounts.set(sub, (subCounts.get(sub) || 0) + 1);
  });

  function toggleContainer(el, countMap) {
    if (!el) return;
    const count = countMap.get(el) || 0;
    el.classList.toggle('is-hidden', count <= 0);
  }

  function hideIndex(idx) {
    const node = nodes[idx];
    if (!node) return;
    if (!node.classList.contains('is-hidden')) {
      node.classList.add('is-hidden');
      applyHighlight(node, null);
      const entry = dataset[idx];
      if (entry.isLink) {
        const cat = entry.catEl; const sub = entry.subEl;
        if (cat) { catCounts.set(cat, (catCounts.get(cat) || 0) - 1); toggleContainer(cat, catCounts); }
        if (sub) { subCounts.set(sub, (subCounts.get(sub) || 0) - 1); toggleContainer(sub, subCounts); }
      }
    }
    visible.delete(idx);
  }

  function showIndex(idx, regex) {
    const node = nodes[idx];
    if (!node) return false;
    let wasHidden = node.classList.contains('is-hidden');
    if (wasHidden) {
      node.classList.remove('is-hidden');
      const entry = dataset[idx];
      if (entry.isLink) {
        const cat = entry.catEl; const sub = entry.subEl;
        if (cat) { catCounts.set(cat, (catCounts.get(cat) || 0) + 1); toggleContainer(cat, catCounts); }
        if (sub) { subCounts.set(sub, (subCounts.get(sub) || 0) + 1); toggleContainer(sub, subCounts); }
      }
      visible.add(idx);
    }
    applyHighlight(node, regex);
    return dataset[idx].isLink;
  }

  return function applyMatches(meta, matches) {
    const matchSet = new Set(matches);
    const toHide = [];
    visible.forEach(idx => { if (!matchSet.has(idx)) toHide.push(idx); });
    toHide.forEach(hideIndex);

    let matchCount = 0;
    matchSet.forEach(idx => { if (showIndex(idx, meta.regex)) matchCount++; });

    if (meta.hasQuery) {
      status.textContent = matchCount > 0 ? `${matchCount} sonuç bulundu` : "Sonuç bulunamadı";
    } else {
      status.textContent = "";
    }
  };
}

function createWorkerSearchEngine(nodes, dataset, status) {
  if (typeof window === "undefined" || typeof window.Worker === "undefined") return null;
  let worker;
  try {
    worker = new Worker(new URL("./searchWorker.js", import.meta.url), { type: "module" });
  } catch (err) {
    console.warn("Search worker could not start:", err);
    return null;
  }
  const applyMatches = createMatchApplier(nodes, dataset, status);
  const pending = new Map();
  let lastQueryId = 0;
  let latestApplied = 0;

  worker.postMessage({ type: "seed", payload: dataset.map(entry => ({ index: entry.index, folded: entry.folded })) });

  worker.addEventListener("message", event => {
    const { type, payload } = event.data || {};
    if (type !== "result" || !payload) return;
    const { id, matches } = payload;
    const meta = pending.get(id);
    pending.delete(id);
    if (!meta || id < latestApplied) return;
    latestApplied = id;
    applyMatches(meta, matches || []);
  });

  return {
    run(query) {
      const meta = createHighlightMeta(query);
      const tokens = tokenizeFoldedQuery(query);
      if (!tokens.length) {
        const matches = dataset.map(entry => entry.index);
        applyMatches(meta, matches);
        return;
      }
      const id = ++lastQueryId;
      pending.set(id, meta);
      worker.postMessage({ type: "query", payload: { id, value: query } });
    }
  };
}

function createSyncSearchEngine(nodes, dataset, status) {
  const applyMatches = createMatchApplier(nodes, dataset, status);
  return {
    run(query) {
      const meta = createHighlightMeta(query);
      const tokens = tokenizeFoldedQuery(query);
      const matches = !tokens.length
        ? dataset.map(entry => entry.index)
        : dataset
            .filter(entry => tokens.every(token => entry.folded.includes(token)))
            .map(entry => entry.index);
      applyMatches(meta, matches);
    }
  };
